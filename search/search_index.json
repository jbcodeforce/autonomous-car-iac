{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"A demonstration for an event-driven solution of autonomous car ride","text":"Updated <p>Created 07/06/2023 - Updated 12/05/23</p> <p>This article illustrates how to apply domain-driven design, and event storming to implement an event-driven solution using different EDA patterns like Event Sourcing, CQRS, and SAGA. The solution is built incrementally adding more complexity over time, so the reader can understand how to apply DDD and all those patterns. There is not a unique solution to implement the requirements, and this repository document different view.</p> <p>It will be a long journey to implement the different patterns and flavor of the solution. </p> <p>As a target implementation, we will use Java, and Python most of the time. The deployment is targeted to use local docker images, and AWS services for cloud deployment. Infrastructure as code is used to deploy dependent services and applications. Some components of the solution will also be AWS Lambda function. The demonstration includes generating CarRides data, that can be used downstream in a Data lake with Analytics.</p> <p>This repository is linked to the EDA book which documents the event-driven design pattern and architecture discussions.</p>"},{"location":"#application-context","title":"Application Context","text":"<p>The customer wants to go from one address or geographic location to another one, within a big city, using the Acme Autonomous Car Ride mobile app. The cars are autonomous cars (robot car) with no pilot. </p> <p>The application context looks like in the following diagram:</p> <p></p> <p>Travelers use mobile application to book a ride between two locations within the same city, the Car Ride Solution dispatches an autonomous vehicle, uses traffic report to compute ETA and pricing. The application is also monitoring existing rides via car telemetries. The Marketing analysis is an example of external system interested by the generated data. </p>"},{"location":"#requirements","title":"Requirements","text":"<ul> <li>User will use a simple user interface to demonstrate booking a car ride and then accept the payment.</li> <li>The first components will be the CarRide management and the car fleet / inventory management.</li> <li>The CarRide management will demonstrate Command Query Responsibility Segregation combined with Event Sourcing.</li> <li>Demonstrate and document the technology choices and fit for purpose.</li> </ul> <p>See event storming and DDD section for business requirements analysis.</p>"},{"location":"#event-sourcing","title":"Event Sourcing","text":"<p>Event sourcing is a design pattern adopted in Event-driven solution. It is not mandatory but it delivers some interesting advantages for such implementation, in particular to explain what happened to the business entity. The CarRide is using the event sourcing pattern, so a dedicated event stores is used to keep the change to the CarRide Entity, as illustrated in the following figure:</p> <p></p> <p>As the first version is supporting Query by Id operation on the CarRide, there is a CarRide table persisted in a SQL based database.</p>"},{"location":"#command-query-responsibility-segregation","title":"Command Query Responsibility Segregation","text":"<p>Command Query Responsibility Segregation is used in a lot of distributed solutions, to be able to scale the read model from the write model. The CarRide service is in fact splitted into Command and Query parts as illustrated in the diagram below:</p> <p></p> <p>Some AWS service, like Amazon DynamoDB by design, is using CQRS with the read replicas feature. </p>"},{"location":"#saga-pattern","title":"Saga pattern","text":"<p>The Saga pattern is used to support distributed long running transaction with compensation mechanism in term of business transaction failure. It is a complex pattern, and the most classical implementation of the Saga is to use an orchestrator to manage the state of the Saga and being able to rollback the transaction with compensation APIs. The second solution is using events to do a Saga choreography.</p>"},{"location":"#adopting-an-event-driven-approach-to-the-implementation","title":"Adopting an event-driven approach to the implementation","text":"<p>The fact that we discovered events during the DDD phase does not mean we adopt EDA. Other non functional requirements need to be considered, like scalability, contract decoupling, reactive system needs, streaming, complex event processing logic... As introduced in the SOA to EDA chapter, a business process model can be used to understand the flow of commands / data and events. </p> <p>Let revisit the business process flow in more detail using the commands, aggregates and events we discovered during the DDD. The BPMN flow illustrates swim lanes for the customer, the car ride manager, the car manager and even the car itself as generators of telemetries:</p> <p></p> <p>Commands are visible as APIs for each task in the flow: CarRideManager swimlane will have at least one service responsible to manage the CarRide, and the activities in the process flow will be exposed as APIs (<code>createCarRide</code>, <code>updateCarRide</code>). </p> <p>Now by looking at this same swim lane, we may want to clearly separate the computation of next available car, and the estimated  time of arrival to a service which manages car information: a CarManager service. The same notifying a customer command, may be in a CustomerManager service. </p> <p>So swim lane to service mapping may be a wrong way to think about decomposition into service. This is why bounded context is a better approach to discover microservices.</p> <p>Now the communication between those services could be synchronous, HTTP based, and using RESTful architecture... or asynchronous using one or more messaging systems. Between the mobile and the API to create a CarRideOrder, we could design it, with RESTful API, stateless. Now once the CarRideOrder is persisted, the logic to find an autonomous car could be make asynchronously with event propagation. A sub-decomposition by applying clear separation of concern could lead to the following components:</p> <ul> <li>The CarRideManagerService uses a Database to persist the CarRide business entity, and generates an event CarRideCreated</li> </ul> <p></p> <ul> <li>The event can be sent to a queue for exactly once processing, and ordered as we do not want to see an <code>CarRideUpdated</code> event before a <code>CarRideCreated</code> event for the same <code>CarRideEntity</code>. </li> <li>The search for an autonomous car and the computation of the ETA and pricing could be done in the <code>CarDispatching</code> service. The command is not exposed as an API but triggered by the consumption of the <code>CarRidCreated</code> Event. This is a EDA approach with choreography. The following figure illustrates the possible end to end components with the different services: </li> </ul> <p></p>"},{"location":"ddd/","title":"Domain-driven design applied","text":"<p>To design a event-driven solution the best approach is to start by using event storming methodology as created by Alberto Brandolini.</p>"},{"location":"ddd/#event-storming","title":"Event Storming","text":"<p>Conducting the event storming workshop involves business subject matter expert, we are mocking it in this section, to first, discover the events. </p> <ul> <li> <p>The discovered Events in the following figure address the happy path of the process of booking a car ride on a robot taxi: </p> <p></p> <p>The Car telemetry events, car problem events and car problem cleared events, are not in the happy path. </p> </li> <li> <p>Event Reorganized by concerns: Rides, Autonomous Car, Payment, Award</p> <p></p> </li> </ul>"},{"location":"ddd/#domain-driven-design-elements","title":"Domain-Driven Design Elements","text":"<ul> <li> <p>Aggregates: represent the main business entity within the domain and sub-domain</p> <p></p> </li> <li> <p>Domain/Sub-domains</p> <p></p> </li> <li> <p>Commands</p> <p></p> <p></p> </li> <li> <p>Bounded Contexts:</p> <ul> <li>Autonomous Car bounded context:</li> </ul> <p></p> <ul> <li>Car Ride bounded context:</li> </ul> <p></p> <ul> <li>Customer and payment bounded contexts are not represented as we will mock them up.</li> </ul> </li> <li> <p>Business service map</p> <p></p> </li> </ul>"},{"location":"ddd/#component-description","title":"Component description","text":"<p>From the Domain-driven design bounded contexts, we may derive a set of microservices as illustrated in the following figure:</p> <p></p> <p>This architecture is interesting, it embraces microservices architecture, mostly synchronous HTTP based traffic. </p> <ul> <li>The traveler user is using a mobile app, connected to the classical Backend For Frontend service, which exposes RESTful API, with may be also a websocket connection to push notifications back to the mobile app to support traffic from backend to user.</li> <li>The major component is the Car Ride manager service which exposes API for the user to initiate a ride to go from a geolocation A to geolocation B, and may be an API for historical rides query.</li> <li>The address finder, geolocation mapper, is an utility service to map address to geo-location and any other metadata to facilitate the search for the optimal itinerary and nearest available car. It is a very important service, and may be complex to implement. It exposes HTTP APIs and must respond in sub millisecond.</li> <li>The Car Ride service needs to integrate with other services, like the Payment service once the ride is terminated, and the Car dispatcher to get an autonomous car.</li> <li>A car dispatcher needs to find the closest car to support the pickup within the shortest time. The computation may take sometime, but the response to the end user will be something like: \"your car will arrive in 3 minutes and the target arrival time will be 15 minutes, do you want to proceed?\". Once commited the car will move to pickup address and sends car telemetries. </li> <li>The metrics are processed by the route monitoring service, which computes ETA, and other interesting real-time, time-windowing logic.</li> <li>When the travel is completed, the payment service needs to trigger the payment and the reward program service may update the number of travel, and may be also rate the consumer. As there is no driver, there is no more driver rating. </li> </ul>"}]}